/** Textual markov chain generator */


class MarkovMachine {
  // build markov machine; read in text.
  // line 13: The constructor takes in a string of text and creates a set of key:value pairs where the key is the word, and 
  // the values are an array of the words that follow that first word each time it appears in the input text
  // line 14: "words" takes "text" and turns it into an array of words by splitting the string at line breaks
  // line 15: this.words uses the .filter() method to make a new array out of "words" by filtering out the spaces, 
  //    resulting an array of words from the input text 
  // line 16: this.makeChains() is calling the makeChains() method on the newly constructed array of words

  constructor(text) {
    let words = text.split(/[ \r\n]+/);
    this.words = words.filter(c => c !== "");
    this.makeChains();
  }

  // Below is an example of the markov chains that should be the output of the makeChains() method, which should be in the 
  // form of a set
  // set markov chains:
  //  for text of "the cat in the hat", chains will be
  //  {"the": ["cat", "hat"], "cat": ["in"], "in": ["the"], "hat": [null]} 

  // line 41: the makeChains() method creates map objects that consist of key:value pairs where the key is a 
  //    word from the input text, and the value is an array of words that follow it in the input text, and then 
  //    puts them into a set of map objects.

  // line 42: defines the variable "chains" as a new Map (a map object consisting of key:value pairs where the key is a 
  //    word from the input text, and the value is an array of words that follow it in the input text)
  // line 43: iterates of the array of words from the input text
  // line 44: defines the variable, "word", as an element from the this.words array"
  // line 45: defines the variable, "nextWord", as an array containing either the element following the i in this.words,
  //    or null if there are no more elements in the this.words array
  // line 46: this if statement checks to see if the "chains" map contains an element with a key equal to word
  // line 47: if "word" is one of the elements in the "chains" map, then it pushes "word" into the nextWord array, which contains 
  // line 48: if "word" is not one of the elements in the "chains" map, then it puts the newly-created "chains" map into a set of map objects consisting of 
  //    the values of the key "word" from the chains objects derived from the input text 
  // line 50: defines this.chains as the set of chains derived from the input text
  
  makeChains() {
    let chains = new Map()
    for(let i=0; i<this.words.length; i+=1) {
      let word = this.words[i];
      let nextWord = this.words[i+1] || null;
      if (chains.has((word))) chains.get(word).push(nextWord);
      else {
        chains.set(word, [nextWord]);
      }
      this.chains = chains;
    }
  }

  // line 58: this static method ...
  // line 59: ...returns a random word from the array

  static choice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // line 73: the makeText() method generates random text from the values in the "chains" set 
  // line 74: defines variable "keys" as an array made from the keys of the maps inside the chains set 
  // line 75: defines variable "key" as the key randomly picked from the newly-created keys array using 
  //    the static choice method.
  // line 76: defines variable "out" as an empty array that will store the text generated by the MarkovMachine
  // line 77: while then numWords and key are not null... produce markov chain until reaching termination word
  // line 78: ...the chosen key is pushed into the "out" array
  // line 79: defines "key" as the randomly chosen key from this.chains
  // line 81: returns the newly-generated text, which consists of a string of the elements of the 'out'
  //    array joined with spaces

  makeText(numWords = 100) {
    let keys = Array.from(this.chains.keys());
    let key = MarkovMachine.choice(keys);
    let out = [];
    while (out.length < numWords && key !== null) {
      out.push(key);
      key = MarkovMachine.choice(this.chains.get(key));
    }
    return out.join(" ");
  }
}


// exports the MarkovMachine class to other files
module.exports = {
  MarkovMachine,
};